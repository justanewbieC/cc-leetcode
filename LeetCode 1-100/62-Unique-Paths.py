'''
本题为一个机器人在一个m*n的网格内走动。机器人初始位置在左上角，要求机器人每次只能
向下或向右走且只能走一步。求机器人走到右下角共有多少种方案。
本题是一个动态规划问题，我本想用递归的方法求解，但调用栈会过多，提示超时。
因此我借鉴discuss中的方法，改用动态规划思想求解。
1.先刻画最优子结构:观察网格可以发现到达某一点的方案数量等于其左边点和上边点的方案之和。
如(i,j)点的方案数=(i-1,j)点的方案数+(i,j-1)点的方案数。
2.再寻找递归求解方案:发现到达第一行和第一列的某点的方案有且只有1种。因此如果用一个
二维数组表示网格，每个元素表示到达这一点的方案数，则可将每个元素初始值设为1。再
利用循环逐个修改所有点的值。
3.计算最优代价:计算最优代价的过程就是循环求解的过程。
4.构造最优解:二维数组最右下角的元素就是我们想要的答案。
本题时间复杂度为O(m*n)，空间复杂度也是m*n。运行时间36ms，击败99.02%用户。
'''
class Solution:
    def uniquePaths(self, m, n):
        if not m or not n: return 0
        dp = [[1]*n for _ in range(m)] #初始设为1
        for i in range(1,m): #从1开始循环，即从第二行开始循环
            for j in range(1,n): #从1开始循环，即从第二列开始循环
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
